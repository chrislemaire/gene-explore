package com.clemaire.gexplore.core.gfa

import java.nio.file.{Files, Path, Paths}

import scala.collection.AbstractSeq

/**
  * A [[List]] of paths generated by the given path to
  * the source GFA-path. The GFA-path generated sibling
  * paths at which header, index, heat-map, etc. files
  * are stored.
  *
  * The [[CachePathList]] allows for iteration over
  * its paths for ease of use. For example one might want
  * to delete all generated additional files, which they
  * might do using a forEach iterator.
  *
  * Note: the collection does not include the originally
  * provided GFA-path, as often we do not need it to iterate
  * over as it has a special function as the source file.
  *
  * @param gfaPath The path to the original source GFA-file
  *                from which cache-files will be generated.
  */
class CachePathList(val gfaPath: Path)
  extends AbstractSeq[Path] {

  /**
    * Whether the application data directory should be the
    * same directory as the original GFA file.
    */
  private val PREFER_LOCAL: Boolean = true

  /**
    * Whether or not to prefer a separate directory per each
    * cache.
    */
  private val PREFER_CACHE_DIRECTORY: Boolean = true

  /**
    * The name of the GFA file without extension.
    */
  private val GFA_NAME: String = {
    val name = gfaPath.getFileName.toString
    if (name.contains('.')) {
      name.substring(0, name.lastIndexOf('.'))
    } else {
      name
    }
  }

  /**
    * The application data directory for Gene Explore.
    */
  private val APP_DATA: Path = {
    val p = Paths.get(
      if (PREFER_LOCAL) {
        gfaPath.getParent.toString
      } else if (System.getProperty("os.name").toLowerCase.contains("win")) {
        System.getenv("AppData") + "/Gene Explore/cache"
      } else {
        System.getProperty("user.home") + "/.gexplore/cache"
      })

    if (PREFER_CACHE_DIRECTORY) p.resolve(s".$GFA_NAME.cache")
    else p
  }

  /**
    * Initializes the app-data directory by checking if
    * it exists and, if not, creating it.
    */
  private val _: Unit = if (!APP_DATA.toFile.exists()) {
    Files.createDirectories(APP_DATA)
  }

  /**
    * Reference-level cache file extension.
    */
  private val REFERENCE_EXT = ".grc"

  /**
    * Reference-level index file extension.
    */
  private val REFERENCE_INDEX_EXT = ".gri"

  /**
    * Heat map file extension.
    */
  private val HEAT_MAP_EXT = ".geh"

  /**
    * Coordinates cache file extension.
    */
  private val COORDINATES_EXT = ".gcc"

  /**
    * Coordinates index file extension.
    */
  private val COORDINATES_INDEX_EXT = ".gci"

  /**
    * Path to the reference-level cache file.
    */
  val referencePath: Path = APP_DATA.resolve(GFA_NAME + REFERENCE_EXT)

  /**
    * Path to the reference-level cache file.
    */
  val referenceIndexPath: Path = APP_DATA.resolve(GFA_NAME + REFERENCE_INDEX_EXT)

  /**
    * Path to the reference-level cache file.
    */
  val heatMapPath: Path = APP_DATA.resolve(GFA_NAME + HEAT_MAP_EXT)

  /**
    * Path to the coordinates cache file.
    */
  val coordinatesPath: Path = APP_DATA.resolve(GFA_NAME + COORDINATES_EXT)

  /**
    * Path to the coordinates index file.
    */
  val coordinatesIndexPath: Path = APP_DATA.resolve(GFA_NAME + COORDINATES_INDEX_EXT)

  /**
    * List of paths used as the underlying structure
    * that is used when querying this [[CachePathList]]
    * as a [[List]].
    */
  private val listOfPaths: List[Path] = List(
    referencePath,
    referenceIndexPath,
    heatMapPath,
    coordinatesPath,
    coordinatesIndexPath)

  override def length: Int = listOfPaths.length

  override def apply(idx: Int): Path = listOfPaths(idx)

  override def iterator: Iterator[Path] = listOfPaths.iterator
}
